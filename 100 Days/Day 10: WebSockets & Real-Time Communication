Polling is a way for the client to repeatedly check the server for updates at fixed intervals. For example, a chat app might send a request every few seconds to see if there are new messages. It’s simple to implement but not very efficient because it causes unnecessary network traffic and delays. That’s why modern apps often use alternatives like WebSockets or SSE for real-time communication, but polling is still useful in scenarios where real-time precision isn’t critical.

Short polling is like the most basic way of checking for updates. The client keeps asking the server at fixed intervals—say every 5 seconds—‘Do you have something new for me?’ If the server has data, it returns it, otherwise it just says ‘nope, nothing new.’ The problem is that this keeps happening whether there’s new data or not, so it ends up wasting bandwidth and puts unnecessary load on the server.
Long polling is a smarter twist on this. Instead of the server immediately saying ‘nothing new,’ it just keeps the connection open and waits until there’s actually something to send. So as soon as new data arrives, the server responds. After that, the client quickly makes another request to wait again. This way, the client doesn’t keep spamming the server and updates feel much closer to real time.
Both of these approaches were used as workarounds to create a real-time-like experience back when we only had HTTP request/response. But nowadays, we mostly rely on WebSockets or Server-Sent Events, which are more efficient ways to handle true real-time communication.”

WebSockets are a protocol that allow persistent, bidirectional communication between client and server. They were standardized in RFC 6455 around 2011, to overcome the inefficiencies of polling or long-polling via HTTP. We need them when our app has real-time requirements—chat, live updates, collaboration—where delays or repeated polling degrade user experience and waste resources. They work by starting with an HTTP upgrade handshake, then keeping a socket open so both sides can send messages at any time. On the frontend we listen for onmessage, send messages, handle errors and reconnections. Examples include chat apps, collaborative editors, live dashboards, stock tickers, and ride tracking. Some drawbacks are the resource usage of many open sockets, network reliability, handling disconnections, security. But with proper design (secure WebSocket, message structure, reconnection, load balancing) WebSockets give much better real-time responsiveness compared to REST polling.
