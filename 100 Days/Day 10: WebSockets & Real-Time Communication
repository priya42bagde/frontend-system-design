Polling is a way for the client to repeatedly check the server for updates at fixed intervals. For example, a chat app might send a request every few seconds to see if there are new messages. It’s simple to implement but not very efficient because it causes unnecessary network traffic and delays. That’s why modern apps often use alternatives like WebSockets or SSE for real-time communication, but polling is still useful in scenarios where real-time precision isn’t critical.


WebSockets are a protocol that allow persistent, bidirectional communication between client and server. They were standardized in RFC 6455 around 2011, to overcome the inefficiencies of polling or long-polling via HTTP. We need them when our app has real-time requirements—chat, live updates, collaboration—where delays or repeated polling degrade user experience and waste resources. They work by starting with an HTTP upgrade handshake, then keeping a socket open so both sides can send messages at any time. On the frontend we listen for onmessage, send messages, handle errors and reconnections. Examples include chat apps, collaborative editors, live dashboards, stock tickers, and ride tracking. Some drawbacks are the resource usage of many open sockets, network reliability, handling disconnections, security. But with proper design (secure WebSocket, message structure, reconnection, load balancing) WebSockets give much better real-time responsiveness compared to REST polling.
